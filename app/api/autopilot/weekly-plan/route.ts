import { NextRequest } from "next/server"
import { z } from "zod"
import { createClient } from "@/lib/supabase/server"
import { fail, ok, parseJsonBody } from "@/lib/api-contract"
import { checkRateLimit } from "@/lib/request-guard"
import { fetchApplicationsCompatible } from "@/lib/supabase/application-compat"

export const dynamic = "force-dynamic"

const FocusAreaSchema = z.enum(["pipeline", "resume", "interview", "networking", "planning"])

const WeeklyPlanSchema = z.object({
  weeklyHours: z.number().min(2).max(80).default(10),
  timezone: z.string().min(2).max(80).default("UTC"),
  startDate: z.string().optional(),
  preferredStartHour: z.number().min(6).max(20).default(9),
  includeWeekend: z.boolean().default(false),
  focusMix: z.array(FocusAreaSchema).min(1).max(5).default(["pipeline", "resume", "interview"]),
})

type FocusArea = z.infer<typeof FocusAreaSchema>

type TaskBlueprint = {
  title: string
  description: string
  durationMin: number
}

type PlanBlock = {
  id: string
  focusArea: FocusArea
  title: string
  description: string
  durationMin: number
  dayLabel: string
  startAt: string
  endAt: string
  calendarLinks: {
    google: string
    outlook: string
  }
}

const TASK_LIBRARY: Record<FocusArea, TaskBlueprint[]> = {
  pipeline: [
    { title: "Pipeline triage sprint", description: "Rank active roles and clear stale blockers.", durationMin: 90 },
    { title: "Follow-up launch window", description: "Send prioritized follow-ups with role-specific context.", durationMin: 60 },
    { title: "Application quality pass", description: "Tighten submissions for top-fit openings.", durationMin: 75 },
  ],
  resume: [
    { title: "Resume variant upgrade", description: "Tune bullet outcomes for target role families.", durationMin: 90 },
    { title: "Achievement proofing", description: "Add metrics and impact proof to weak bullets.", durationMin: 60 },
    { title: "Role-fit keyword pass", description: "Align resume language with current job signals.", durationMin: 75 },
  ],
  interview: [
    { title: "Mock interview rep", description: "Run one focused mock and score clarity/depth.", durationMin: 60 },
    { title: "Story bank drill", description: "Refine STAR stories for leadership and execution.", durationMin: 75 },
    { title: "Question simulation", description: "Practice company-specific prompts and concise answers.", durationMin: 60 },
  ],
  networking: [
    { title: "Referral outreach cadence", description: "Send tailored notes to warm contacts and alumni.", durationMin: 60 },
    { title: "Coffee chat prep + send", description: "Prepare briefs, send asks, and log next steps.", durationMin: 75 },
    { title: "Network momentum review", description: "Prioritize relationships by response potential.", durationMin: 45 },
  ],
  planning: [
    { title: "Weekly operating review", description: "Close wins, misses, and next-best actions.", durationMin: 60 },
    { title: "Calendar rebalance", description: "Reallocate time blocks to protect high-impact work.", durationMin: 45 },
    { title: "Forecast checkpoint", description: "Compare plan vs conversion signals and adjust.", durationMin: 45 },
  ],
}

function getClientIp(request: NextRequest) {
  return request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() || "0.0.0.0"
}

function clamp(value: number, min: number, max: number) {
  return Math.max(min, Math.min(max, value))
}

function normalizeDateOnly(value?: string) {
  if (!value) {
    const now = new Date()
    now.setHours(0, 0, 0, 0)
    return now
  }
  const parsed = new Date(`${value}T00:00:00`)
  if (Number.isNaN(parsed.getTime())) {
    const now = new Date()
    now.setHours(0, 0, 0, 0)
    return now
  }
  parsed.setHours(0, 0, 0, 0)
  return parsed
}

function formatGoogleDate(value: Date) {
  return value
    .toISOString()
    .replace(/[-:]/g, "")
    .replace(/\.\d{3}Z$/, "Z")
}

function escapeIcsText(value: string) {
  return value.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/,/g, "\\,").replace(/;/g, "\\;")
}

function buildCalendarLinks(block: {
  title: string
  description: string
  startAt: string
  endAt: string
  timezone: string
}) {
  const start = new Date(block.startAt)
  const end = new Date(block.endAt)
  const details = `${block.description}\nGenerated by Climb Weekly Autopilot`
  const google = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(block.title)}&dates=${formatGoogleDate(start)}/${formatGoogleDate(end)}&details=${encodeURIComponent(details)}&ctz=${encodeURIComponent(block.timezone)}`
  const outlook = `https://outlook.office.com/calendar/0/deeplink/compose?path=/calendar/action/compose&rru=addevent&subject=${encodeURIComponent(block.title)}&startdt=${encodeURIComponent(start.toISOString())}&enddt=${encodeURIComponent(end.toISOString())}&body=${encodeURIComponent(details)}`
  return { google, outlook }
}

function buildIcs(blocks: PlanBlock[]) {
  const lines = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//Climb//Weekly Autopilot//EN",
    "CALSCALE:GREGORIAN",
  ]

  const stamp = formatGoogleDate(new Date())

  for (const block of blocks) {
    const start = formatGoogleDate(new Date(block.startAt))
    const end = formatGoogleDate(new Date(block.endAt))
    lines.push("BEGIN:VEVENT")
    lines.push(`UID:${block.id}@climb.app`)
    lines.push(`DTSTAMP:${stamp}`)
    lines.push(`DTSTART:${start}`)
    lines.push(`DTEND:${end}`)
    lines.push(`SUMMARY:${escapeIcsText(block.title)}`)
    lines.push(`DESCRIPTION:${escapeIcsText(block.description)}`)
    lines.push("END:VEVENT")
  }

  lines.push("END:VCALENDAR")
  return lines.join("\r\n")
}

function prioritizeFocusMix(input: FocusArea[], context: { staleApplications: number; interviewCount: number; replyCount: number }) {
  const weights = new Map<FocusArea, number>()
  for (const focus of input) weights.set(focus, 1)

  if (context.staleApplications >= 3) {
    weights.set("pipeline", (weights.get("pipeline") || 0) + 2)
    weights.set("networking", (weights.get("networking") || 0) + 1)
  }
  if (context.interviewCount >= 2) {
    weights.set("interview", (weights.get("interview") || 0) + 2)
  }
  if (context.replyCount <= 1) {
    weights.set("resume", (weights.get("resume") || 0) + 1)
  }

  return Array.from(weights.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([focus]) => focus)
}

function buildWeeklyBlocks(input: {
  weeklyHours: number
  startDate?: string
  preferredStartHour: number
  includeWeekend: boolean
  focusMix: FocusArea[]
  timezone: string
}): PlanBlock[] {
  const blocks: PlanBlock[] = []
  const totalMinutes = Math.round(input.weeklyHours * 60)
  const targetDays = input.includeWeekend ? 7 : 5
  const baseDate = normalizeDateOnly(input.startDate)
  const dayMinuteBudget = Math.max(45, Math.round(totalMinutes / targetDays))

  let remainingMinutes = totalMinutes
  let blockCounter = 0

  for (let dayOffset = 0; dayOffset < 7 && remainingMinutes > 0; dayOffset++) {
    const dayDate = new Date(baseDate)
    dayDate.setDate(baseDate.getDate() + dayOffset)
    const day = dayDate.getDay()
    if (!input.includeWeekend && (day === 0 || day === 6)) continue

    let dayRemaining = Math.min(dayMinuteBudget, remainingMinutes)
    let cursorHour = input.preferredStartHour
    let cursorMinute = 0

    while (dayRemaining >= 30 && remainingMinutes > 0) {
      const focus = input.focusMix[blockCounter % input.focusMix.length]
      const templates = TASK_LIBRARY[focus]
      const blueprint = templates[blockCounter % templates.length]
      const durationMin = clamp(blueprint.durationMin, 30, Math.min(120, dayRemaining, remainingMinutes))

      const startAt = new Date(dayDate)
      startAt.setHours(cursorHour, cursorMinute, 0, 0)
      const endAt = new Date(startAt.getTime() + durationMin * 60_000)
      const dayLabel = startAt.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" })
      const id = `${startAt.getTime()}-${focus}-${blockCounter}`

      const title = `${blueprint.title} (${focus})`
      const description = blueprint.description
      const links = buildCalendarLinks({
        title,
        description,
        startAt: startAt.toISOString(),
        endAt: endAt.toISOString(),
        timezone: input.timezone,
      })

      blocks.push({
        id,
        focusArea: focus,
        title,
        description,
        durationMin,
        dayLabel,
        startAt: startAt.toISOString(),
        endAt: endAt.toISOString(),
        calendarLinks: links,
      })

      remainingMinutes -= durationMin
      dayRemaining -= durationMin
      blockCounter += 1
      cursorHour = endAt.getHours() + 1
      cursorMinute = 0
      if (cursorHour >= 20) break
    }
  }

  return blocks
}

export async function POST(request: NextRequest) {
  const rate = checkRateLimit(`autopilot-weekly:${getClientIp(request)}`, 40, 60_000)
  if (!rate.allowed) return fail("Rate limit exceeded", 429, { resetAt: rate.resetAt })

  try {
    const body = await parseJsonBody(request, WeeklyPlanSchema)
    const supabase = await createClient()
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return fail("Unauthorized", 401)

    const applications = await fetchApplicationsCompatible(supabase, user.id)
    const activeStatuses = new Set(["applied", "screening", "interview"])
    const staleThresholdMs = 10 * 24 * 60 * 60 * 1000
    const now = Date.now()
    const staleApplications = applications.filter((item) => {
      if (!item.status || !activeStatuses.has(item.status.toLowerCase())) return false
      const ts = Date.parse(item.created_at || item.applied_date || "")
      if (Number.isNaN(ts)) return false
      return now - ts >= staleThresholdMs
    }).length

    const interviewCount = applications.filter((item) => item.status?.toLowerCase() === "interview").length
    const replyCount = applications.filter((item) => {
      const status = item.status?.toLowerCase() || ""
      return status === "screening" || status === "interview" || status === "offer"
    }).length

    const prioritizedFocus = prioritizeFocusMix(body.focusMix, {
      staleApplications,
      interviewCount,
      replyCount,
    })

    const blocks = buildWeeklyBlocks({
      weeklyHours: body.weeklyHours,
      startDate: body.startDate,
      preferredStartHour: body.preferredStartHour,
      includeWeekend: body.includeWeekend,
      focusMix: prioritizedFocus,
      timezone: body.timezone,
    })

    const totalsByFocus = blocks.reduce<Record<FocusArea, number>>(
      (acc, block) => {
        acc[block.focusArea] += block.durationMin
        return acc
      },
      {
        pipeline: 0,
        resume: 0,
        interview: 0,
        networking: 0,
        planning: 0,
      }
    )

    const todayActions = blocks.slice(0, 3).map((item) => ({
      title: item.title,
      startAt: item.startAt,
      durationMin: item.durationMin,
    }))

    return ok({
      success: true,
      generatedAt: new Date().toISOString(),
      context: {
        activeApplications: applications.length,
        staleApplications,
        interviewCount,
        replyCount,
      },
      plan: {
        timezone: body.timezone,
        weeklyHours: body.weeklyHours,
        focusPriority: prioritizedFocus,
        totalsByFocus,
        blocks,
        todayActions,
        ics: buildIcs(blocks),
      },
    })
  } catch (error) {
    const message = error instanceof Error ? error.message : "Failed to generate weekly autopilot plan"
    return fail(message, 500)
  }
}

